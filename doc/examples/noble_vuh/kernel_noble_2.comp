#version 440

layout(local_size_x_id = 0, local_size_y_id = 1) in; // workgroup dimensions specialization constants
layout(push_constant) uniform Parameters {
   uint cellCountX;
   uint cellCountY;
   float dt_sim;
   uint i;
} p;
layout(std430, binding = 0) buffer lay0 { float I[]; };
layout(std430, binding = 1) buffer lay1 { float V_YX[]; };
layout(std430, binding = 2) buffer lay2 { float V_tYX_reg[]; };

const float Cm = .12,
        Area = 7.6e-3;// mm2 3e-8*1e6, //7.6e-5, //veikia prie 1.96e-8*1e6, //bandymu keliu, plotas nebutinai yra tikras last., tiesiog kad vyktu sklidimas prie realaus PJ laidumo88


void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x < p.cellCountX && y < p.cellCountY) {
        uint adr = p.cellCountX*y + x;

//        if (uint(p.i*p.dt_sim) % uint(p.dt_reg) == 0) {
//            uint i_reg = uint(p.i*p.dt_sim) / uint(p.dt_reg);
//            V_tYX_reg[i_reg*p.cellCountX*p.cellCountY+adr] = V_YX[adr];
//        }
        V_tYX_reg[p.i*p.cellCountX*p.cellCountY+adr] = V_YX[adr];

        float V = V_YX[adr];

        float up = 100 + 60;
        float I_ext =( (p.i > 100 && p.i < 100 + 2) // I_ext Protokolas
                   ||  (p.i > up && p.i < up + 2) )
                      &&  (y > 32 - 2 && y < 32 + 2
                        && x > 64 - 2 && x < 64 + 2 ) ? 0.08 : 0;
        V_YX[adr] = V + p.dt_sim*(I_ext + I[adr]) / (Cm*Area);
    }
}
